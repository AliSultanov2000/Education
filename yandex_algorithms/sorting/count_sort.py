# Пусть необходимо отсортировать массив из N целых чисел, каждое от 0 до К 

# Будем считать кол-во вхождений каждого числа, а затем выводить каждое число столько раз,
# сколько оно встречалось. Это займёт О(N+K) и O(K) дополнительной памяти

# Важно: стандартная сортировка работает не быстрее, чем O(N*logN), но в таком классе задач,
# где каждое зн-е лежит в промежутке O-K - займёт O(N + K)

# Если зн-я массива лежат в пределах 100000, то использовать этот метод - нецелесообразно 
# Сортировка подсчётом часто применяется при решении прикладных задач

nums = list(map(int, input().split()))
k = max(nums)

digit_count = [0] * (k + 1)  # 0 элемент - кол-во нулей в списке, 1 - й элемент - кол-во 1 и тд
sorted_arr = []

# Сложность O(N)
for num in nums: 
    digit_count[num] += 1

# Сложность O(K)
for num_idx in range(len(digit_count)):
    if digit_count[num_idx] > 0:
        sorted_arr.extend([num_idx] * digit_count[num_idx])
    
# Общая сложность O(N + K)
print(sorted_arr)
